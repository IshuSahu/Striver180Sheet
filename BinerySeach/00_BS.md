## **1. What is Binary Search?**

Binary Search is an algorithm to **search for an element in a sorted array (or monotonic function)** by repeatedly dividing the search range in half.

### Why it’s powerful:

* **Time Complexity:** `O(log n)`
* Works not just for searching exact matches but also for:

  * Finding **first occurrence** or **last occurrence**
  * Finding the **smallest/largest value** that satisfies a condition
  * Solving problems over **search space** (not just arrays)

---

## **2. How it works (Mental Model)**

Imagine you have a sorted array:

```
Index:  0   1   2   3   4   5   6
Value:  2   4   6   8   10  12  14
```

You want to search for `10`.

Steps:

1. Start with `low = 0`, `high = 6`
2. Find `mid = low + (high - low) / 2` → avoids overflow
3. Compare:

   * If `arr[mid] == target` → found
   * If `arr[mid] < target` → search in right half (`low = mid + 1`)
   * If `arr[mid] > target` → search in left half (`high = mid - 1`)

---

## **3. The "Two Flavors" of Binary Search**

### **A. Search for exact element**

Classic textbook binary search:

```cpp
int binarySearch(vector<int> &arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```

---

### **B. Search for boundary condition**

This is where **most interview problems hide** — they don’t just ask "is target present?" but something like:

* First index where `arr[i] >= target`
* Last index where `arr[i] <= target`
* Minimum x such that `f(x)` is true

In these, **loop condition and update rules differ**:

```cpp
int lowerBound(vector<int> &arr, int target) {
    int low = 0, high = arr.size(); // notice high = n
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] < target) low = mid + 1;
        else high = mid;
    }
    return low; // first position where arr[i] >= target
}
```

---

## **4. Things to Watch Out for in Binary Search Problems**

### **A. Precondition**

* **Sorted input** or **monotonic property** (array or function must be non-decreasing or non-increasing).
* If array isn’t sorted, binary search **doesn’t apply** directly.

---

### **B. Loop condition**

* **`while (low <= high)`** → used for exact search (returns when found)
* **`while (low < high)`** → used for finding boundaries/minimum satisfying condition

---

### **C. Mid calculation**

* **NEVER** do `(low + high) / 2` in competitive programming — it may overflow.
* Use:

```cpp
mid = low + (high - low) / 2;
```

---

### **D. Infinite loop traps**

If you do `low = mid` or `high = mid` without adjusting by `+1` or `-1`, you can get stuck.

* When `arr[mid] < target`, do `low = mid + 1`
* When `arr[mid] > target`, do `high = mid - 1`

---

### **E. When solving "Search Space" problems**

Binary Search is not just for arrays — think of it as **"shrinking the range until you find the smallest/largest answer that satisfies a condition"**.

Steps:

1. Define `low`, `high` range of possible answers.
2. Write a `check(mid)` function that returns `true` if `mid` satisfies the condition.
3. Use binary search to find the **first true** or **last true** in that space.

Example:
**Problem** – Minimum capacity of ship to transport packages in `D` days.

* Range: `low = max(weights)`, `high = sum(weights)`
* `check(mid)` → can we ship in `D` days with capacity = `mid`?

---

## **5. Common Interview Patterns**

| Pattern          | Goal                         | Loop Condition | Update Rule                                     |
| ---------------- | ---------------------------- | -------------- | ----------------------------------------------- |
| Exact search     | Find target value            | `low <= high`  | `low = mid + 1` / `high = mid - 1`              |
| Lower bound      | First `arr[i] >= target`     | `low < high`   | `high = mid` if condition, else `low = mid + 1` |
| Upper bound      | First `arr[i] > target`      | `low < high`   | `high = mid` if condition, else `low = mid + 1` |
| Search space min | Minimum satisfying condition | `low < high`   | `high = mid` if true, else `low = mid + 1`      |
| Search space max | Maximum satisfying condition | `low < high`   | `low = mid + 1` if true, else `high = mid`      |

---

## **6. Mental Checklist Before Coding Binary Search**

1. **Is the array or function monotonic?**
2. **What am I looking for?**

   * Exact match?
   * First/last occurrence?
   * Min/Max satisfying condition?
3. **What is the initial `low` and `high`?**
4. **When does the loop stop?**
5. **What should I return?**
6. **Am I preventing infinite loop by adjusting mid properly?**

---

