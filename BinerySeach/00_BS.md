# üß≠ Binary Search ‚Äî Pattern Wise Mastery Guide

---

## üöÄ 1Ô∏è‚É£ What Is Binary Search?

**Definition:**
Binary Search is a divide-and-conquer algorithm used to find an element in a sorted array (or search space) in `O(log n)` time.

Instead of checking every element linearly, it repeatedly divides the search space in half.

---

## üß© 2Ô∏è‚É£ Core Idea

At every step:

1. Compute `mid = low + (high - low) / 2`
2. Compare `arr[mid]` with the target.

   * If equal ‚Üí return `mid`
   * If smaller ‚Üí search right half (`low = mid + 1`)
   * If greater ‚Üí search left half (`high = mid - 1`)

---

## üìö 3Ô∏è‚É£ Binary Search Pattern Families

Binary Search problems come in **7 main patterns**:

| # | Pattern Name                          | Core Use Case                             |
| - | ------------------------------------- | ----------------------------------------- |
| 1 | Classic Binary Search                 | Find element index in sorted array        |
| 2 | Lower Bound / Upper Bound             | First or last occurrence                  |
| 3 | Search in Rotated Sorted Array        | Array rotated by pivot                    |
| 4 | Binary Search on Answer               | Min/Max optimization over a numeric range |
| 5 | Search in 2D Matrix                   | Flattened or row-wise sorted              |
| 6 | Binary Search on Real Numbers         | For floating range precision              |
| 7 | Binary Search with Predicate Function | When you can check ‚Äúfeasibility‚Äù          |

---

## üß† 4Ô∏è‚É£ Pattern-Wise Deep Dive

---

### üß© **Pattern 1: Classic Binary Search**

**When to use:**
You need to find the index of a target element in a **sorted array**.

**Steps to Solve:**

1. Initialize `low = 0`, `high = n - 1`
2. While `low <= high`:

   * `mid = low + (high - low) / 2`
   * If `arr[mid] == target` ‚Üí return `mid`
   * Else if `arr[mid] < target` ‚Üí `low = mid + 1`
   * Else ‚Üí `high = mid - 1`
3. If not found ‚Üí return `-1`

**Example:**

```cpp
int binarySearch(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```

‚úÖ **Example Input:**
`arr = [1, 3, 5, 7, 9], target = 7` ‚Üí Output: `3`

**Practice Problems:**

* [Leetcode 704. Binary Search](https://leetcode.com/problems/binary-search/)
* [Find Element in Infinite Sorted Array](https://leetcode.com/discuss/interview-question/125002/)

---

### üß© **Pattern 2: Lower Bound / Upper Bound**

**When to use:**
Find **first** or **last** position of target (or insertion point).

**Concept:**

* **Lower Bound** ‚Üí first element ‚â• target
* **Upper Bound** ‚Üí first element > target

**Steps:**

1. `low = 0, high = n`
2. While `low < high`

   * `mid = (low + high) / 2`
   * If `arr[mid] < target` ‚Üí `low = mid + 1`
   * Else ‚Üí `high = mid`
3. `low` is your lower bound

**Example:**
Find first occurrence of `2` in `[1,2,2,3,3]`

```cpp
int lowerBound(vector<int>& arr, int target) {
    int low = 0, high = arr.size();
    while (low < high) {
        int mid = (low + high) / 2;
        if (arr[mid] < target) low = mid + 1;
        else high = mid;
    }
    return low;
}
```

‚úÖ Output: `1`

**Practice Problems:**

* [Leetcode 34. Find First and Last Position of Element](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
* [Ceil and Floor in Sorted Array]

---

### üß© **Pattern 3: Search in Rotated Sorted Array**

**When to use:**
Array is sorted but **rotated** by some pivot.

**Steps:**

1. Use binary search normally but check which half is sorted.
2. If left half is sorted:

   * If `target` in range ‚Üí search left
   * Else ‚Üí search right
3. If right half is sorted:

   * If `target` in range ‚Üí search right
   * Else ‚Üí search left

**Example:**

```cpp
int search(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == target) return mid;
        if (arr[low] <= arr[mid]) { // Left sorted
            if (arr[low] <= target && target < arr[mid]) high = mid - 1;
            else low = mid + 1;
        } else { // Right sorted
            if (arr[mid] < target && target <= arr[high]) low = mid + 1;
            else high = mid - 1;
        }
    }
    return -1;
}
```

‚úÖ Example: `[4,5,6,7,0,1,2], target=0` ‚Üí Output: `4`

**Practice Problems:**

* [Leetcode 33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
* [Leetcode 81. Search in Rotated Sorted Array II (with duplicates)]

---

### üß© **Pattern 4: Binary Search on Answer**

**When to use:**
We can‚Äôt binary search on array directly ‚Äî we binary search on **numeric range** (e.g., min time, min capacity, etc.)

**Steps:**

1. Define search space: `[low, high]`
2. Mid = potential answer
3. Write a `check(mid)` function that tests if it‚Äôs feasible
4. Use binary search to minimize or maximize

**Example:**
üß† *Koko Eating Bananas* (Leetcode 875)

```cpp
bool canEat(vector<int>& piles, int h, int k) {
    long hours = 0;
    for (int pile : piles) hours += ceil((double)pile / k);
    return hours <= h;
}

int minEatingSpeed(vector<int>& piles, int h) {
    int low = 1, high = *max_element(piles.begin(), piles.end()), ans = high;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (canEat(piles, h, mid)) { ans = mid; high = mid - 1; }
        else low = mid + 1;
    }
    return ans;
}
```

‚úÖ Output: Minimum speed `k`

**Practice Problems:**

* [Leetcode 875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)
* [Leetcode 1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)
* [Aggressive Cows (SPOJ)]

---

### üß© **Pattern 5: Binary Search in 2D Matrix**

**When to use:**
2D matrix sorted row-wise or column-wise ‚Üí flatten search or binary search row-wise.

**Example:** Leetcode 74 ‚Äî Search a 2D Matrix

```cpp
bool searchMatrix(vector<vector<int>>& mat, int target) {
    int n = mat.size(), m = mat[0].size();
    int low = 0, high = n*m - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        int val = mat[mid/m][mid%m];
        if (val == target) return true;
        else if (val < target) low = mid + 1;
        else high = mid - 1;
    }
    return false;
}
```

**Practice Problems:**

* [Leetcode 74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)
* [Leetcode 240. Search a 2D Matrix II]

---

### üß© **Pattern 6: Binary Search on Real Numbers**

**When to use:**
For precision-based answers (like square root, cube root, etc.)

**Steps:**

1. Set low, high (range of possible values)
2. Run loop while `(high - low) > epsilon`
3. Compute mid, check condition, adjust bounds

**Example:**
Find ‚àöN up to 5 decimal places

```cpp
double sqrtPrecision(int n, double precision=1e-5) {
    double low = 0, high = n, mid;
    while (high - low > precision) {
        mid = (low + high) / 2.0;
        if (mid * mid < n) low = mid;
        else high = mid;
    }
    return (low + high) / 2.0;
}
```

**Practice Problems:**

* Square root with precision
* Nth root of a number

---

### üß© **Pattern 7: Binary Search with Predicate Function**

**When to use:**
You can check if a **condition is True/False** and you need the **first True** or **last False** point.

**Steps:**

1. Define a predicate function `f(x)`
2. Binary search on range to find boundary where `f(x)` changes from False ‚Üí True

**Example:** Minimum days to make bouquets (Leetcode 1482)

```cpp
bool canMake(vector<int>& bloom, int m, int k, int day) {
    int flowers = 0, bouquets = 0;
    for (int b : bloom) {
        if (b <= day) flowers++;
        else flowers = 0;
        if (flowers == k) { bouquets++; flowers = 0; }
    }
    return bouquets >= m;
}

int minDays(vector<int>& bloom, int m, int k) {
    if ((long)m*k > bloom.size()) return -1;
    int low = *min_element(bloom.begin(), bloom.end());
    int high = *max_element(bloom.begin(), bloom.end());
    int ans = -1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (canMake(bloom, m, k, mid)) { ans = mid; high = mid - 1; }
        else low = mid + 1;
    }
    return ans;
}
```

**Practice Problems:**

* [Leetcode 1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)
* [Leetcode 410. Split Array Largest Sum]

---

## üß≠ 5Ô∏è‚É£ Binary Search Checklist Before Coding

‚úÖ Is the search space **sorted** or **monotonic**?
‚úÖ Can you express the problem as finding a ‚Äúboundary‚Äù (first True / False)?
‚úÖ Is there a **feasibility function** (`check(mid)`) you can binary search on?
‚úÖ Define the **range** properly (`low`, `high`) and **avoid infinite loops**.

---

## 6Ô∏è‚É£. Mental Checklist Before Coding Binary Search

1. **Is the array or function monotonic?**
2. **What am I looking for?**

   * Exact match?
   * First/last occurrence?
   * Min/Max satisfying condition?
3. **What is the initial `low` and `high`?**
4. **When does the loop stop?**
5. **What should I return?**
6. **Am I preventing infinite loop by adjusting mid properly?**

---

